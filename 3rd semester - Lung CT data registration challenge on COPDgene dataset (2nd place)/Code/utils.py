import numpy as np
import nibabel as nib
from scipy import ndimage
from skimage import measure
from scipy import stats
import cv2
import re

'''
    FUNCTION NAME : calculateTRE
    Takes in the fixed and moving landmarks and calculates 3D Eucleadian Distance
    INPUTS:
        landmarks_fixed : N x 3 np array containing the fixed landmarks indices
        landmarks_moving : N x 3 np array containing the moving landmarks indices
        voxel_dimensions : the voxel spacing tuple of length 3
    RETURNS:
        mean_tre: The mean of the tre calculated
        std_tre : The std of the tre calculated
'''


def calculateTRE(landmarks_fixed, landmarks_moving, voxel_dimensions):
    # Taking into account the voxel size
    landmarks_moving = voxel_dimensions * landmarks_moving
    landmarks_fixed = voxel_dimensions * landmarks_fixed

    # Calculated the squared difference
    tre = np.sqrt(np.sum((landmarks_fixed - landmarks_moving) ** 2, axis=1))

    # Calculating the mean and std tre
    mean_tre = np.mean(tre)
    std_tre = np.std(tre)

    return mean_tre, std_tre

'''
    FUNCTION NAME : get_landmarks_from_elastix_file
    Takes in the fixed and moving landmarks and calculates 3D Eucleadian Distance
    INPUTS:
        landmarks_fixed : N x 3 np array containing the fixed landmarks indices
        landmarks_moving : N x 3 np array containing the moving landmarks indices
        voxel_dimensions : the voxel spacing tuple of length 3
    RETURNS:
        transformed_landmarks: The landmarks extracted from the point transformation
                               file generated by elastix
'''

def get_landmarks_from_elastix_file (filepath):

    registered_landmarks = np.zeros((300, 3))
    transformed_landmarks_file = open(filepath, "r")
    regular_expression = r'OutputIndexFixed = \[([\d.\s\-]+)\]'

    for i, line in enumerate(transformed_landmarks_file):

        object_string_match = re.search(regular_expression, line, re.M)
        indices = object_string_match.group(1).split()
        indices = [round(float(c)) for c in indices]
        registered_landmarks[i,:] = indices

    return registered_landmarks


def line_prepender(filename, line):
    with open(filename, 'r+') as f:
        content = f.read()
        f.seek(0, 0)
        f.write(line.rstrip('\r\n') + '\n' + content)


"""A function that takes a String specifiying the path the the nifit image and return a
    3D csegmentation nifit image

     This code is adapted from XXX"""

def segment3DLungs(image_path):

    # Lungs Parameters
    params = {}
    # Parameters for intensity (fixed)
    params['lungMinValue'] = 0
    params['lungMaxValue'] = 800
    params['lungThreshold'] = -900
    # Parameters for lung segmentation (fixed)
    params['xRangeRatio1'] = 0.4
    params['xRangeRatio2'] = 0.75
    params['zRangeRatio1'] = 0.5
    params['zRangeRatio2'] = 0.75

    # Load image
    Img = nib.load(image_path)
    I = Img.get_data()

    # Intensity thresholding & Morphological operations
    M = np.zeros(I.shape)
    M[I > params['lungMinValue']] = 1
    M[I > params['lungMaxValue']] = 0

    struct_s = ndimage.generate_binary_structure(3, 1)
    struct_m = ndimage.iterate_structure(struct_s, 2)
    struct_l = ndimage.iterate_structure(struct_s, 3)
    M = ndimage.binary_closing(M, structure=struct_s, iterations=1)
    M = ndimage.binary_opening(M, structure=struct_m, iterations=1)

    # Estimate lung filed of view
    [m, n, p] = I.shape
    medx = int(m / 2)
    medy = int(n / 2)
    xrange1 = int(m / 2 * params['xRangeRatio1'])
    xrange2 = int(m / 2 * params['xRangeRatio2'])
    zrange1 = int(p * params['zRangeRatio1'])
    zrange2 = int(p * params['zRangeRatio2'])

    # Select largest connected components
    M = measure.label(M)
    label1 = M[medx - xrange2: medx - xrange1, medy, zrange1: zrange2]
    label2 = M[medx + xrange1: medx + xrange2, medy, zrange1: zrange2]
    label1 = stats.mode(label1[label1 > 0])[0][0]
    label2 = stats.mode(label2[label2 > 0])[0][0]
    M[M == label1] = -1
    M[M == label2] = -1
    M[M > 0] = 0
    M = M * -1

    SegImage = nib.Nifti1Image(M, Img.affine, Img.header)

    return SegImage


